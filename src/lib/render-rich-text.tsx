import React from "react";

/**
 * Renders a limited subset of HTML (generated by Tiptap) as React elements.
 * Supported tags: <strong>, <em>, <u>, <s>, <span style="color:...">,
 * <mark style="background-color:..." data-color="...">, <p>, <br>
 *
 * Falls back to plain text if no HTML tags are present.
 */
export function renderRichText(html: string): React.ReactNode {
  if (!html) return null;
  // Fast path: no HTML tags at all → return as-is
  if (!html.includes("<")) return html;

  // Strip outer <p>...</p> wrapper if it's a single paragraph
  const stripped = html.replace(/^<p>([\s\S]*)<\/p>$/, "$1");

  return parseFragment(stripped);
}

/** Parse an HTML fragment into React nodes */
function parseFragment(html: string): React.ReactNode {
  const nodes: React.ReactNode[] = [];
  let cursor = 0;
  let keyCounter = 0;

  while (cursor < html.length) {
    const tagStart = html.indexOf("<", cursor);
    if (tagStart === -1) {
      // Remaining text
      nodes.push(decodeEntities(html.slice(cursor)));
      break;
    }

    // Text before the tag
    if (tagStart > cursor) {
      nodes.push(decodeEntities(html.slice(cursor, tagStart)));
    }

    // Self-closing <br> or <br/>
    if (html.startsWith("<br", tagStart)) {
      const brEnd = html.indexOf(">", tagStart);
      if (brEnd !== -1) {
        nodes.push(<br key={keyCounter++} />);
        cursor = brEnd + 1;
        continue;
      }
    }

    // Paragraph breaks: </p><p> → line break
    if (html.startsWith("</p><p>", tagStart)) {
      nodes.push(<br key={keyCounter++} />);
      cursor = tagStart + 7; // skip </p><p>
      continue;
    }

    // Closing </p> at end — skip
    if (html.startsWith("</p>", tagStart)) {
      cursor = tagStart + 4;
      continue;
    }

    // Opening <p> — skip (content follows)
    if (html.startsWith("<p>", tagStart)) {
      cursor = tagStart + 3;
      continue;
    }

    // Parse opening tag
    const match = html.slice(tagStart).match(/^<(\w+)([^>]*)>/);
    if (!match) {
      // Malformed tag — treat '<' as literal
      nodes.push("<");
      cursor = tagStart + 1;
      continue;
    }

    const [fullTag, tagName, attrs] = match;
    const closingTag = `</${tagName}>`;
    const closingIdx = html.indexOf(closingTag, tagStart + fullTag.length);

    if (closingIdx === -1) {
      // No closing tag — treat as literal
      nodes.push(decodeEntities(fullTag));
      cursor = tagStart + fullTag.length;
      continue;
    }

    const inner = html.slice(tagStart + fullTag.length, closingIdx);
    const children = parseFragment(inner);
    const key = keyCounter++;

    switch (tagName) {
      case "strong":
      case "b":
        nodes.push(<strong key={key}>{children}</strong>);
        break;
      case "em":
      case "i":
        nodes.push(<em key={key}>{children}</em>);
        break;
      case "u":
        nodes.push(<u key={key}>{children}</u>);
        break;
      case "s":
        nodes.push(<s key={key}>{children}</s>);
        break;
      case "code":
        nodes.push(
          <code
            key={key}
            style={{
              backgroundColor: "rgba(135,131,120,0.15)",
              borderRadius: "3px",
              padding: "0.1em 0.3em",
              fontSize: "0.9em",
              fontFamily:
                '"SFMono-Regular", Menlo, Consolas, "PT Mono", "Liberation Mono", Courier, monospace',
            }}
          >
            {children}
          </code>
        );
        break;
      case "span": {
        const color = extractStyleProp(attrs, "color");
        nodes.push(
          <span key={key} style={color ? { color } : undefined}>
            {children}
          </span>
        );
        break;
      }
      case "mark": {
        const bg =
          extractStyleProp(attrs, "background-color") ||
          extractDataAttr(attrs, "color");
        nodes.push(
          <mark
            key={key}
            style={bg ? { backgroundColor: bg, borderRadius: "2px" } : undefined}
          >
            {children}
          </mark>
        );
        break;
      }
      default:
        // Unknown tag — render children only (strip tag)
        nodes.push(<React.Fragment key={key}>{children}</React.Fragment>);
    }

    cursor = closingIdx + closingTag.length;
  }

  if (nodes.length === 0) return null;
  if (nodes.length === 1) return nodes[0];
  return <>{nodes}</>;
}

/** Extract a CSS property value from an inline style attribute string */
function extractStyleProp(attrs: string, prop: string): string | null {
  const styleMatch = attrs.match(/style="([^"]*)"/);
  if (!styleMatch) return null;
  const re = new RegExp(`${prop}\\s*:\\s*([^;"]+)`);
  const m = styleMatch[1].match(re);
  return m ? m[1].trim() : null;
}

/** Extract a data-* attribute value */
function extractDataAttr(attrs: string, name: string): string | null {
  const re = new RegExp(`data-${name}="([^"]*)"`);
  const m = attrs.match(re);
  return m ? m[1] : null;
}

/**
 * Renders a full Tiptap block document as React elements.
 * Handles: <ul>, <ol>, <li>, <h2>, <h3>, <h4>, <blockquote>, <p>
 * Inline formatting (bold, italic, color, etc.) handled by parseFragment.
 *
 * Set --bullet-color CSS var on a parent element to color list markers.
 */
export function renderRichDocument(html: string): React.ReactNode {
  if (!html) return null;
  if (!html.includes("<")) return html;

  const blocks = parseBlocks(html);
  if (blocks.length === 0) return null;
  if (blocks.length === 1) return blocks[0];
  return <>{blocks}</>;
}

/** Parse top-level block elements from Tiptap HTML */
function parseBlocks(html: string): React.ReactNode[] {
  const nodes: React.ReactNode[] = [];
  let cursor = 0;
  let keyCounter = 0;

  while (cursor < html.length) {
    // Skip whitespace between blocks
    const nextTag = html.indexOf("<", cursor);
    if (nextTag === -1) {
      const remaining = html.slice(cursor).trim();
      if (remaining) nodes.push(decodeEntities(remaining));
      break;
    }
    // Text between blocks (shouldn't happen normally, but handle it)
    if (nextTag > cursor) {
      const text = html.slice(cursor, nextTag).trim();
      if (text) nodes.push(decodeEntities(text));
    }

    // Match opening tag
    const match = html.slice(nextTag).match(/^<(\w+)([^>]*)>/);
    if (!match) {
      cursor = nextTag + 1;
      continue;
    }

    const [fullTag, tagName] = match;
    const closingTag = `</${tagName}>`;

    // Find matching closing tag (handling nesting for ul/ol)
    const closingIdx = findMatchingClose(html, nextTag + fullTag.length, tagName);
    if (closingIdx === -1) {
      cursor = nextTag + fullTag.length;
      continue;
    }

    const inner = html.slice(nextTag + fullTag.length, closingIdx);
    const key = keyCounter++;

    switch (tagName) {
      case "ul":
        nodes.push(
          <ul key={key} className="list-disc pl-[1.2em] space-y-0.5" style={{ color: "var(--bullet-color, currentColor)" }}>
            {parseListItems(inner)}
          </ul>
        );
        break;
      case "ol":
        nodes.push(
          <ol key={key} className="list-decimal pl-[1.2em] space-y-0.5" style={{ color: "var(--bullet-color, currentColor)" }}>
            {parseListItems(inner)}
          </ol>
        );
        break;
      case "h2":
        nodes.push(<h2 key={key} className="font-semibold text-[1.15em] text-gray-900">{parseFragment(inner)}</h2>);
        break;
      case "h3":
        nodes.push(<h3 key={key} className="font-semibold text-[1.05em] text-gray-800">{parseFragment(inner)}</h3>);
        break;
      case "h4":
        nodes.push(<h4 key={key} className="font-medium text-[1em] text-gray-700">{parseFragment(inner)}</h4>);
        break;
      case "blockquote":
        nodes.push(
          <blockquote key={key} className="border-l-2 border-gray-300 dark:border-gray-600 pl-2 italic text-gray-600">
            {parseBlocks(inner)}
          </blockquote>
        );
        break;
      case "p":
        nodes.push(
          <p key={key} className="leading-relaxed text-gray-600">
            {inner ? parseFragment(inner) : "\u00a0"}
          </p>
        );
        break;
      default:
        // Unknown block — render inline content
        nodes.push(<React.Fragment key={key}>{parseFragment(inner)}</React.Fragment>);
    }

    cursor = closingIdx + closingTag.length;
  }

  return nodes;
}

/** Parse <li> elements inside a list */
function parseListItems(html: string): React.ReactNode[] {
  const items: React.ReactNode[] = [];
  let cursor = 0;
  let keyCounter = 0;

  while (cursor < html.length) {
    const liStart = html.indexOf("<li", cursor);
    if (liStart === -1) break;

    const tagEnd = html.indexOf(">", liStart);
    if (tagEnd === -1) break;

    const closingIdx = findMatchingClose(html, tagEnd + 1, "li");
    if (closingIdx === -1) break;

    const inner = html.slice(tagEnd + 1, closingIdx);
    // <li> content is typically wrapped in <p>, or can contain nested lists
    const content = inner.includes("<ul") || inner.includes("<ol")
      ? parseBlocks(inner)
      : parseBlocks(inner);

    items.push(
      <li key={keyCounter++} className="leading-relaxed text-gray-600">
        {content}
      </li>
    );

    cursor = closingIdx + 5; // skip </li>
  }

  return items;
}

/** Find the matching closing tag, handling same-tag nesting */
function findMatchingClose(html: string, start: number, tagName: string): number {
  let depth = 1;
  let pos = start;
  const openTag = `<${tagName}`;
  const closeTag = `</${tagName}>`;

  while (pos < html.length && depth > 0) {
    const nextOpen = html.indexOf(openTag, pos);
    const nextClose = html.indexOf(closeTag, pos);

    if (nextClose === -1) return -1; // no closing tag

    if (nextOpen !== -1 && nextOpen < nextClose) {
      // Verify it's a real open tag (not <h2something>)
      const charAfter = html[nextOpen + openTag.length];
      if (charAfter === ">" || charAfter === " ") {
        depth++;
      }
      pos = nextOpen + openTag.length;
    } else {
      depth--;
      if (depth === 0) return nextClose;
      pos = nextClose + closeTag.length;
    }
  }

  return -1;
}

/** Decode basic HTML entities */
function decodeEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, "\u00a0");
}
