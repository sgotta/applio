import React from "react";
import { Text, View } from "@react-pdf/renderer";
import type { Style } from "@react-pdf/types";

/**
 * Renders a limited subset of HTML (generated by Tiptap) as react-pdf <Text> elements.
 * Supported: <strong>, <em>, <u>, <s>, <span style="color:...">,
 * <mark style="background-color:...">, <p>, <br>
 *
 * Plain text (no HTML) is returned as a simple <Text>.
 */
export function PdfRichText({
  html,
  style,
}: {
  html: string;
  style: Style;
}): React.ReactElement {
  if (!html) return <Text style={style}> </Text>;
  if (!html.includes("<")) return <Text style={style}>{html}</Text>;

  // Strip outer <p>...</p> if single paragraph
  const stripped = html.replace(/^<p>([\s\S]*)<\/p>$/, "$1");

  const children = parsePdfFragment(stripped);
  return <Text style={style}>{children}</Text>;
}

/** Parse an HTML fragment into react-pdf Text nodes */
function parsePdfFragment(html: string): React.ReactNode[] {
  const nodes: React.ReactNode[] = [];
  let cursor = 0;
  let keyCounter = 0;

  while (cursor < html.length) {
    const tagStart = html.indexOf("<", cursor);
    if (tagStart === -1) {
      nodes.push(decodeEntities(html.slice(cursor)));
      break;
    }

    if (tagStart > cursor) {
      nodes.push(decodeEntities(html.slice(cursor, tagStart)));
    }

    // <br> / <br/>
    if (html.startsWith("<br", tagStart)) {
      const brEnd = html.indexOf(">", tagStart);
      if (brEnd !== -1) {
        nodes.push("\n");
        cursor = brEnd + 1;
        continue;
      }
    }

    // </p><p> â†’ newline
    if (html.startsWith("</p><p>", tagStart)) {
      nodes.push("\n");
      cursor = tagStart + 7;
      continue;
    }

    // Skip </p> and <p>
    if (html.startsWith("</p>", tagStart)) {
      cursor = tagStart + 4;
      continue;
    }
    if (html.startsWith("<p>", tagStart)) {
      cursor = tagStart + 3;
      continue;
    }

    // Parse opening tag
    const match = html.slice(tagStart).match(/^<(\w+)([^>]*)>/);
    if (!match) {
      nodes.push("<");
      cursor = tagStart + 1;
      continue;
    }

    const [fullTag, tagName, attrs] = match;
    const closingTag = `</${tagName}>`;
    const closingIdx = html.indexOf(closingTag, tagStart + fullTag.length);

    if (closingIdx === -1) {
      nodes.push(decodeEntities(fullTag));
      cursor = tagStart + fullTag.length;
      continue;
    }

    const inner = html.slice(tagStart + fullTag.length, closingIdx);
    const children = parsePdfFragment(inner);
    const key = keyCounter++;

    switch (tagName) {
      case "strong":
      case "b":
        nodes.push(
          <Text key={key} style={{ fontWeight: 700 }}>
            {children}
          </Text>
        );
        break;
      case "em":
      case "i":
        nodes.push(
          <Text key={key} style={{ fontStyle: "italic" }}>
            {children}
          </Text>
        );
        break;
      case "u":
        nodes.push(
          <Text key={key} style={{ textDecoration: "underline" }}>
            {children}
          </Text>
        );
        break;
      case "s":
        nodes.push(
          <Text key={key} style={{ textDecoration: "line-through" }}>
            {children}
          </Text>
        );
        break;
      case "code":
        nodes.push(
          <Text
            key={key}
            style={{
              backgroundColor: "rgba(135,131,120,0.15)",
            }}
          >
            {children}
          </Text>
        );
        break;
      case "span": {
        const color = extractStyleProp(attrs, "color");
        if (color) {
          nodes.push(
            <Text key={key} style={{ color }}>
              {children}
            </Text>
          );
        } else {
          nodes.push(...children);
        }
        break;
      }
      case "mark": {
        // react-pdf has limited background-color support on inline Text;
        // use the color as a subtle tint if background doesn't work
        const bg =
          extractStyleProp(attrs, "background-color") ||
          extractDataAttr(attrs, "color");
        nodes.push(
          <Text key={key} style={bg ? { backgroundColor: bg } : undefined}>
            {children}
          </Text>
        );
        break;
      }
      default:
        nodes.push(...children);
    }

    cursor = closingIdx + closingTag.length;
  }

  return nodes;
}

/**
 * Renders a full Tiptap block document as react-pdf elements.
 * Handles: <ul>, <ol>, <li>, <h2>, <h3>, <h4>, <blockquote>, <p>
 */
export function PdfRichDocument({
  html,
  fontSize,
  bulletColor,
}: {
  html: string;
  fontSize: number;
  bulletColor: string;
}): React.ReactElement {
  if (!html) return <View />;
  const blocks = parsePdfBlocks(html, fontSize, bulletColor);
  return <View style={{ gap: 3 }}>{blocks}</View>;
}

function parsePdfBlocks(
  html: string,
  fontSize: number,
  bulletColor: string,
): React.ReactNode[] {
  const nodes: React.ReactNode[] = [];
  let cursor = 0;
  let keyCounter = 0;

  while (cursor < html.length) {
    const nextTag = html.indexOf("<", cursor);
    if (nextTag === -1) {
      const remaining = html.slice(cursor).trim();
      if (remaining) {
        nodes.push(<Text key={keyCounter++} style={{ fontSize, color: "#374151", lineHeight: 1.55 }}>{decodeEntities(remaining)}</Text>);
      }
      break;
    }
    if (nextTag > cursor) {
      const text = html.slice(cursor, nextTag).trim();
      if (text) {
        nodes.push(<Text key={keyCounter++} style={{ fontSize, color: "#374151", lineHeight: 1.55 }}>{decodeEntities(text)}</Text>);
      }
    }

    const match = html.slice(nextTag).match(/^<(\w+)([^>]*)>/);
    if (!match) {
      cursor = nextTag + 1;
      continue;
    }

    const [fullTag, tagName] = match;
    const closingIdx = findPdfMatchingClose(html, nextTag + fullTag.length, tagName);
    if (closingIdx === -1) {
      cursor = nextTag + fullTag.length;
      continue;
    }

    const inner = html.slice(nextTag + fullTag.length, closingIdx);
    const key = keyCounter++;

    switch (tagName) {
      case "ul":
        nodes.push(
          <View key={key} style={{ gap: 2 }}>
            {parsePdfListItems(inner, "bullet", fontSize, bulletColor)}
          </View>
        );
        break;
      case "ol":
        nodes.push(
          <View key={key} style={{ gap: 2 }}>
            {parsePdfListItems(inner, "ordered", fontSize, bulletColor)}
          </View>
        );
        break;
      case "h2":
        nodes.push(
          <PdfRichText key={key} html={inner} style={{ fontSize: fontSize * 1.15, fontWeight: 600, color: "#111827", marginTop: 6 }} />
        );
        break;
      case "h3":
        nodes.push(
          <PdfRichText key={key} html={inner} style={{ fontSize: fontSize * 1.05, fontWeight: 600, color: "#1f2937" }} />
        );
        break;
      case "h4":
        nodes.push(
          <PdfRichText key={key} html={inner} style={{ fontSize, fontWeight: 500, color: "#374151" }} />
        );
        break;
      case "blockquote":
        nodes.push(
          <View key={key} style={{ borderLeftWidth: 2, borderLeftColor: "#d1d5db", paddingLeft: 8 }}>
            {parsePdfBlocks(inner, fontSize, bulletColor)}
          </View>
        );
        break;
      case "p":
        nodes.push(
          <PdfRichText key={key} html={inner || "\u00a0"} style={{ fontSize, color: "#374151", lineHeight: 1.55, width: "100%" }} />
        );
        break;
      default:
        nodes.push(
          <PdfRichText key={key} html={inner} style={{ fontSize, color: "#374151", lineHeight: 1.55 }} />
        );
    }

    cursor = closingIdx + `</${tagName}>`.length;
  }

  return nodes;
}

function parsePdfListItems(
  html: string,
  listType: "bullet" | "ordered",
  fontSize: number,
  bulletColor: string,
): React.ReactNode[] {
  const items: React.ReactNode[] = [];
  let cursor = 0;
  let keyCounter = 0;
  let numCounter = 0;

  while (cursor < html.length) {
    const liStart = html.indexOf("<li", cursor);
    if (liStart === -1) break;

    const tagEnd = html.indexOf(">", liStart);
    if (tagEnd === -1) break;

    const closingIdx = findPdfMatchingClose(html, tagEnd + 1, "li");
    if (closingIdx === -1) break;

    const inner = html.slice(tagEnd + 1, closingIdx);
    const key = keyCounter++;

    // Strip <p> wrapper inside <li>
    const stripped = inner.replace(/^<p>([\s\S]*)<\/p>$/, "$1");

    // Check for nested lists inside this <li>
    const hasNestedList = inner.includes("<ul") || inner.includes("<ol");

    if (listType === "ordered") numCounter++;

    items.push(
      <View key={key} style={{ flexDirection: "row", paddingLeft: 9 }}>
        <Text style={{ color: bulletColor, marginRight: 5, fontSize }}>
          {listType === "ordered" ? `${numCounter}.` : "\u2022"}
        </Text>
        {hasNestedList ? (
          <View style={{ flex: 1 }}>
            {parsePdfBlocks(inner, fontSize, bulletColor)}
          </View>
        ) : (
          <PdfRichText html={stripped} style={{ fontSize, color: "#374151", flex: 1, lineHeight: 1.55 }} />
        )}
      </View>
    );

    cursor = closingIdx + 5; // skip </li>
  }

  return items;
}

function findPdfMatchingClose(html: string, start: number, tagName: string): number {
  let depth = 1;
  let pos = start;
  const openTag = `<${tagName}`;
  const closeTag = `</${tagName}>`;

  while (pos < html.length && depth > 0) {
    const nextOpen = html.indexOf(openTag, pos);
    const nextClose = html.indexOf(closeTag, pos);

    if (nextClose === -1) return -1;

    if (nextOpen !== -1 && nextOpen < nextClose) {
      const charAfter = html[nextOpen + openTag.length];
      if (charAfter === ">" || charAfter === " ") {
        depth++;
      }
      pos = nextOpen + openTag.length;
    } else {
      depth--;
      if (depth === 0) return nextClose;
      pos = nextClose + closeTag.length;
    }
  }

  return -1;
}

function extractStyleProp(attrs: string, prop: string): string | null {
  const styleMatch = attrs.match(/style="([^"]*)"/);
  if (!styleMatch) return null;
  const re = new RegExp(`${prop}\\s*:\\s*([^;"]+)`);
  const m = styleMatch[1].match(re);
  return m ? m[1].trim() : null;
}

function extractDataAttr(attrs: string, name: string): string | null {
  const re = new RegExp(`data-${name}="([^"]*)"`);
  const m = attrs.match(re);
  return m ? m[1] : null;
}

function decodeEntities(text: string): string {
  return text
    .replace(/&amp;/g, "&")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&nbsp;/g, "\u00a0");
}
